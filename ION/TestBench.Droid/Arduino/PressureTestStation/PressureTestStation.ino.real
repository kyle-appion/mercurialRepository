/*
The following is per christian 29 Dec 2016:

The pressure rig should be designed such that is is able to perform both calibration and nist procedures.

This requires that the rig have two steppers controllers that will isolate the test from the g5 and the exhaust. Further,
test and calibration target points are to be relative. The rig does not need to precisely reach a desired target point
as the only thing that matters is a test gauges proximity to the reference (fluke) at the target point.

That said, this program only needs to preform the following functions which will be identified as states:
  * pressure up
  * hold pressure
  * pressure down
  * shudown safely
*/



#include <string.h>

#include <SoftwareSerial.h>

#include "Appion.h"
#include "BluetoothController.h"
#include "Fluke700G.h"
#include "VctControlStepper.h"

#define DEBUG true
#define VERBOSE false

#define IS_HIGH_CCW false     // The direction of the control stepper
// Stepper 1 Pin layouts
#define PIN_STEPPER_1_DIR 46  // The pin that will output the stepper 1 motor direction
#define PIN_STEPPER_1_STEP 47 // The pin that will output the stepper 1 motor step
#define PIN_STEPPER_1_START_SWITCH 40 // The pin stepper 1's home detection switch
#define PIN_STEPPER_1_END_SWITCH 42   // The pin stepper 1's end detection switch
// G5 Start Relay
#define PIN_G5_START_RELAY 41     // The pin that, when high, will start the G5
// Status LED
#define PIN_ERROR_LED 53          // The led that is used to indicate an error

#define BLUEFRUIT_SPI_SCK 52      // The pin to the bluefruit's SCK system clock
#define BLUEFRUIT_SPI_MISO 50     // The pin to the bluefruit's MISO pin
#define BLUEFRUIT_SPI_MOSI 51     // The pin to the bluefruit's MOSI pin
#define BLUEFRUIT_SPI_CS 49       // The pin to the bluefruit's CS pin
#define BLUEFRUIT_SPI_IRQ 48      // The pin to the bluefruit's IQR pin
#define BLUEFRUIT_SPI_RST 22      // The pin to the bluefruit's RST pin

#define FLUKE_TX 0                // The pin that is used to perform tx to the fluke
#define FLUKE_RX 1                // The pin that is used to perform rx to the fluke

// The enumeration of state that the rig controller is able to accept.
enum ERigState {
  // The state/command that will shut the rig
  RC_SHUTDOWN = 1,
  // The state/command type that puts the rig into an idle state.
  RC_IDLE = 2,
  // The state/command type that puts the rig into a pressurize until target state.
  RC_PRESSURIZE = 3,
  // The state/command type that puts the rig into a hold pressure state.
  RC_HOLD_PRESSURE = 4,
  // The state/command that will depressurize the rig.
  RC_DEPRESSUIZE = 5,
  // The state/command that will is used when the rig crashes.
  RC_CRASH = 6,
};

// The enumeration of the error codes that are present in the rig.
enum EErrorCode {
  // The error code that indicates that the fluke failed to communicate with the rig.
  ERR_FLUKE_COMM_FAIL = 1,
};

//  The bluetooth controller that will wrap the general bluetooth communication objects.
BluetoothController* bt;
// The fluke gauge controller.
Fluke700G* fluke;
// The stepper that is used to block off pressure from the g5.
VctControlStepper* g5Stepper;
// The stepper that will exhaust the rig.
VctControlStepper* exhaustStepper;

// The current state of the rig.
ERigState state;
// The current error code for the rig.
EErrorCode errorCode;
// The last known pressure that the was received from the fluke gauge.
f32 flukePressure;
// The milliseconds since the last time that the fluke measurement was updated.
u32 timeSinceLastUpdate;

void Crash() {
  Shutdown();

  u32 lastTime;
  while (true) {
    digitalWrite(PIN_G5_START_RELAY, 0);
    if (micros() - lastTime > 500) {
      digitalWrite(PIN_ERROR_LED, !digitalRead(PIN_ERROR_LED));
      lastTime = micros();
    }
  }
}

void CrashWithWrite() {
  WriteBluetooth();
  Crash();
}

void DoIdle() {
  // Do nothing
}

void DoInitialize() {
  // Do Nothing
}

// Pressurizes the rig.
void DoPressurize() {
  g5Stepper->SetRPS(5);
  g5Stepper->RotateToDegree(0);

  exhaustStepper->SetRPS(5);
  exhaustStepper->RotateToDegree(90);

  PowerG5(true);
}


void DoHoldPressure() {
  g5Stepper->SetRPS(5);
  g5Stepper->RotateToDegree(90);

  exhaustStepper->SetRPS(5);
  exhaustStepper->RotateToDegree(90);

  PowerG5(false);
}

// Depressurizes the rig.
void DoDepressurize() {
  g5Stepper->SetRPS(5);
  g5Stepper->RotateToDegree(0);

  exhaustStepper->SetRPS(0.05);
  exhaustStepper->RotateToDegree(0);

  PowerG5(false);
}

// Shuts the rig down.
void Shutdown() {
  bt->Disconnect();
  PowerG5(false);
  stepper->SetRPS(0.05);
  stepper->RotateToDegree(0);
  while (stepper->IsSteppingComplete()) {
    stepper->SafeStep();
  }
}

void PowerG5(bool on) {
  if (on) {
    digitalWrite(PIN_G5_START_RELAY, 1);
    digitalWrite(PIN_ERROR_LED, 1);
  } else {
    digitalWrite(PIN_G5_START_RELAY, 0);
    digitalWrite(PIN_ERROR_LED, 0);
  }
}


// Updates the current measurement from the fluke gauge.
void UpdateFlukeMeasurement() {
  f32 meas = 0;
  EFlukeError err = fluke->GetPressure(&meas);
  if (err != Fl_Err_Ok) {
    CrashWithCode(ERR_FLUKE_COMM_FAIL);
  } else {
    lastKnownPressure = meas;
  }
}


// Parses a command from the given buffer. Note: the returned command is malloc'd onto the heap and thus needs to be
// freed.
void ResolveBluetoothInput() {
  u8 buffer[20];
  int cnt = bt->ReadFrom(bt->localReadCharacteristic, buffer, 20);
  if (cnt == 0 || buffer[0] == 0) {
    return;
  }

  ERigState newState = (ERigState)((int)(p++));
  state = newState;

  bt->ClearCharacteristic(bt->localWriteCharacteristic);
}

/*
Output protocol
Bytes | Type  | Description
------+-------------------------------------------------------------
 1    | u8    | The current state of the rig
 4    | f32   | The current fluke measurement
 4    | f32   | The current g5 stepper angle
 4    | f32   | The current exhaust angle
*/
// Write the current rig state to bluetooth.
void WriteBluetooth() {
  u8 buffer[20];
  u8* p = buffer;

  u8 bState = (u8)state;
  f32 g5Theta = g5Stepper->GetCurrentPositionAsDegrees();
  f32 exhaustTheta = exhaustStepper->GetCurrentPositionAsDegrees();

  // should be 17 bytes total
  memcpymov(p, &bState, 1);
  memcpymov(p, &errorCode, sizeof(errorCode));
  memcpymov(p, &flukePressure, sizeof(f32));
  memcpymov(p, &g5Theta, sizeof(f32));
  memcpymov(p, &exhaustTheta, sizeof(f32));
}

/**********************************************************************************************************************
 * ARDUINO CONTROL CODE
 *********************************************************************************************************************/

void setup() {
  pinMode(PIN_ERROR_LED, OUTPUT);
  pinMode(PIN_G5_START_RELAY, OUTPUT);

  bt = new BluetoothController(BLUEFRUIT_SPI_CS, BLUEFRUIT_SPI_IRQ, BLUEFRUIT_SPI_RST, "PR00Z001");
  stepper = new VctControlStepper(PIN_STEPPER_1_DIR, IS_HIGH_CCW, PIN_STEPPER_1_STEP, 5000, 10, PIN_STEPPER_1_START_SWITCH, PIN_STEPPER_1_END_SWITCH);
  fluke = new Fluke700G(FLUKE_TX, FLUKE_RX);
}

void loop() {
  UpdateFlukeMeasurement();

  // Save our souls from an overpressure event
  if (flukePressure > 950) {
    Shutdown();
    CrashWithWrite();
  }

  ResolveBluetoothInput();

  switch (state) {
    case RC_IDLE:
      DoIdle();
      break;
    case RC_PRESSURIZE:
      DoPressurize();
      break;
    case RC_DEPRESSURIZE:
      DoDepressurize();
      break;
    case RC_HOLD_PRESSURE:
      DoHoldPressure();
    case RC_SHUTDOWN:
      Shutdown();
    default:
      // Nope
  }

  if (!g5Stepper->IsSteppingComplete()) {
    g5Stepper->SafeStep();
  }

  if (!exhaustStepper->IsSteppingComplete()) {
    exhaustStepper->SafeStep();
  }

  WriteBluetooth();
}
