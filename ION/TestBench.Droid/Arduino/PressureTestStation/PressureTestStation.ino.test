#include <SoftwareSerial.h>
#include <string.h>

#include "Appion.h"
#include "BluetoothController.h"
#include "Fluke700G.h"
#include "Timer.h"
#include "VctControlStepper.h"

#define DEBUG true

#define IS_HIGH_CCW false     // The direction of the control stepper
// Stepper 1 Pin layouts
#define PIN_STEPPER_1_DIR 46  // The pin that will output the stepper 1 motor direction
#define PIN_STEPPER_1_STEP 47 // The pin that will output the stepper 1 motor step
#define PIN_STEPPER_1_START_SWITCH 40 // The pin stepper 1's home detection switch
#define PIN_STEPPER_1_END_SWITCH 42   // The pin stepper 1's end detection switch
// G5 Start Relay
#define PIN_G5_START_RELAY 41     // The pin that, when high, will start the G5
// Status LED
#define PIN_ERROR_LED 53          // The led that is used to indicate an error

#define BLUEFRUIT_SPI_SCK 52      // The pin to the bluefruit's SCK system clock
#define BLUEFRUIT_SPI_MISO 50     // The pin to the bluefruit's MISO pin
#define BLUEFRUIT_SPI_MOSI 51     // The pin to the bluefruit's MOSI pin
#define BLUEFRUIT_SPI_CS 49       // The pin to the bluefruit's CS pin
#define BLUEFRUIT_SPI_IRQ 48      // The pin to the bluefruit's IQR pin
#define BLUEFRUIT_SPI_RST 22      // The pin to the bluefruit's RST pin

#define FLUKE_TX 2                // The pin that is used to perform tx to the fluke
#define FLUKE_RX 3                // The pin that is used to perform rx to the fluke

SoftwareSerial fluke(FLUKE_RX, FLUKE_TX, false);
BluetoothController* bt;
VctControlStepper* stepper;

u32 iters;

void Reset() {
  stepper->SetRPS(1);

  stepper->RotateByDegree(-360);
  while (!stepper->IsVctAtStart()) {
    stepper->SafeStep();
  }

  stepper->RotateByDegree(360);
  while (!stepper->IsVctAtEnd()) {
    stepper->SafeStep();
  }
}

void setup() {
  Serial.begin(9600);
  fluke.begin(9600);

  bt = new BluetoothController(BLUEFRUIT_SPI_CS, BLUEFRUIT_SPI_IRQ, BLUEFRUIT_SPI_RST, "PR00Z001");
//  stepper = new VctControlStepper(PIN_STEPPER_1_DIR, IS_HIGH_CCW, PIN_STEPPER_1_STEP, 5000, 10, PIN_STEPPER_1_START_SWITCH, PIN_STEPPER_1_END_SWITCH);

  bt->Begin(false);

//  Reset();

  WriteToFluke("Hello, World", 12);
  bt->ClearCharacteristic(bt->localReadCharacteristic);

  iters = 0;
}


void loop() {
  char* b1 = "PRES_UNIT Bar";
  char* b2 = "PRES_UNIT Psi";
  char* b3 = "PRES_UNIT Kg/cm2";

  fluke.write(b1, 13);
  fluke.println();
  delay(1000);
  fluke.write(b2, 13);
  fluke.println();
  delay(1000);
  fluke.write(b3, 16);
  fluke.println();
  delay(1000);
  fluke.print("*IDN?\r");
  fluke.flush();
  delay(1000);
  Serial.println("Reading from IDN");
  char buffer[32];
  int cnt = FlukeReadLine(buffer, 32, 10 * 1000);

  Serial.print("Cnt: ");
  Serial.println(cnt);
  Serial.write(buffer, cnt);
  Serial.println();

/*
  u8 buffer[32];
  memset(buffer, 0, 32);
  int cnt = 0;

  if (bt->IsConnected()) {
    cnt = bt->ReadFrom(bt->localReadCharacteristic, buffer, 20);
    if (buffer[0] == 0 || cnt == 0) {
      // We didn't get a new command yet
      return;
    }
    int tmp = cnt;
    cnt = Trim(buffer, cnt);
    Serial.print("Cnt was: ");
    Serial.print(tmp, DEC);
    Serial.print(" now is: ");
    Serial.println(cnt, DEC);
    WriteToFluke((char*)(buffer + 1), cnt - 1);
    cnt = SerialReadLine((char*)buffer, 32, 10 * 1000);
    if (cnt > 0) {
      Serial.write(buffer, cnt);
      Serial.println();
      bt->WriteTo(bt->localWriteCharacteristic, buffer, 32);
    }

    bt->ClearCharacteristic(bt->localReadCharacteristic);
  }

  delay(1000);
*/
}

void WriteToFluke(char* buffer, int len) {
  Serial.write(buffer, len);
  Serial.println();
//  fluke.write(buffer, len);
//  fluke.println();
  fluke.print("*IDN\r\n");
  fluke.flush();
}

// Reads a line from the serial into the given buffer, up to the given maximum number of characters. If the procedure
// timesout or exceeds the size of the buffer, then the return value will be negative.
// Return: the number of characters read. Will be negative on error.
int FlukeReadLine(char* buffer, int max, int timeout) {
  return fluke.readBytesUntil('\n', buffer, max);
  /*
  int i = 0;
  while (timeout) {
    Serial.print("Timeout: ");
    Serial.println(timeout, DEC);

    while (!fluke.available() && timeout > 0) {
      delay(1);
      timeout--;
      if (timeout % 500 == 0) {
        Serial.print("Timeout: ");
        Serial.println(timeout, DEC);
      }
    }

    while (fluke.available()) {
      if (i >= max) {
        return -i;
      }
      int r = fluke.read();
      Serial.println((char)r);
      if (r != -1) {
        char c = (char)r;
        buffer[i++] = c;
        if (c == '\n') {
          return i;
        }
      }
    }
  }

  Serial.print("Read count: ");
  Serial.println(i, DEC);
  return -i;
  */
}

int Trim(u8* buffer, int len) {
  int i = len - 1;
  for (;i >= 0; i--) {
    if (buffer[i] != 0) {
      return i + 1;
    }
  }

  return i;
}
